/**
 * Test for Combat Focus Management Fix
 * 
 * This test verifies that the combat overlay properly manages focus
 * to ensure immediate interactivity when it appears
 */

import React from 'react';
import { render, screen, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { CombatContainer } from '../features/combat/components/CombatContainer';

describe('Combat Focus Management', () => {
  beforeEach(() => {
    // Reset focus to body before each test
    document.body.focus();
  });

  it('should focus the container when combat overlay appears', async () => {
    const TestContent = () => (
      <button data-testid="test-button">Test Action</button>
    );

    render(
      <CombatContainer>
        <TestContent />
      </CombatContainer>
    );

    // Wait for the focus timer (100ms delay)
    await waitFor(() => {
      const container = screen.getByRole('dialog');
      expect(document.activeElement).toBe(container);
    }, { timeout: 200 });
  });

  it('should store and restore previous focus when overlay closes', async () => {
    // Create a button that will have focus before combat
    const previousButton = document.createElement('button');
    previousButton.textContent = 'Previous Focus';
    document.body.appendChild(previousButton);
    previousButton.focus();
    
    expect(document.activeElement).toBe(previousButton);

    const { unmount } = render(
      <CombatContainer>
        <div>Combat Content</div>
      </CombatContainer>
    );

    // Wait for container to take focus
    await waitFor(() => {
      const container = screen.getByRole('dialog');
      expect(document.activeElement).toBe(container);
    }, { timeout: 200 });

    // Unmount the component
    unmount();

    // Verify focus returns to previous element
    expect(document.activeElement).toBe(previousButton);

    // Cleanup
    document.body.removeChild(previousButton);
  });

  it('should trap focus within the combat overlay on Tab navigation', async () => {
    const user = userEvent.setup();

    render(
      <CombatContainer>
        <button data-testid="first-button">First Action</button>
        <button data-testid="second-button">Second Action</button>
        <button data-testid="third-button">Third Action</button>
      </CombatContainer>
    );

    const firstButton = screen.getByTestId('first-button');
    const thirdButton = screen.getByTestId('third-button');

    // Focus the first button
    firstButton.focus();
    expect(document.activeElement).toBe(firstButton);

    // Shift+Tab from first button should wrap to last button
    await user.keyboard('{Shift>}{Tab}{/Shift}');
    expect(document.activeElement).toBe(thirdButton);

    // Tab from last button should wrap to first button
    await user.keyboard('{Tab}');
    expect(document.activeElement).toBe(firstButton);
  });

  it('should have proper ARIA attributes for accessibility', () => {
    render(
      <CombatContainer>
        <div>Combat Content</div>
      </CombatContainer>
    );

    const container = screen.getByRole('dialog');
    
    // Verify ARIA attributes
    expect(container).toHaveAttribute('aria-modal', 'true');
    expect(container).toHaveAttribute('aria-label', 'Combat interface');
    expect(container).toHaveAttribute('tabindex', '-1');
  });

  it('should apply focus ring styles when focused', async () => {
    render(
      <CombatContainer>
        <div>Combat Content</div>
      </CombatContainer>
    );

    const container = screen.getByRole('dialog');
    
    // Wait for auto-focus
    await waitFor(() => {
      expect(document.activeElement).toBe(container);
    }, { timeout: 200 });

    // Check for focus ring classes
    expect(container).toHaveClass('focus:outline-none');
    expect(container).toHaveClass('focus:ring-2');
    expect(container).toHaveClass('focus:ring-primary-500');
  });

  it('should allow buttons within the overlay to be immediately clickable', async () => {
    const handleClick = vi.fn();

    render(
      <CombatContainer>
        <button data-testid="action-button" onClick={handleClick}>
          Combat Action
        </button>
      </CombatContainer>
    );

    const button = screen.getByTestId('action-button');
    
    // Button should be immediately clickable without needing to click elsewhere first
    await userEvent.click(button);
    
    expect(handleClick).toHaveBeenCalledTimes(1);
  });
});