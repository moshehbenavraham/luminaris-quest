// GENERATED BY BOLT.NEW â€“ DO NOT EDIT MANUALLY

import { create } from 'zustand';
import { persist } from 'zustand/middleware';
import { useEffect, useState } from 'react';
import type { JournalEntry } from '@/components/JournalModal';
import type { DatabaseHealthStatus /* , DatabaseHealthCheckResult */ } from '@/lib/database-health';
// TEMPORARILY COMMENTED OUT FOR BUILD: DatabaseHealthCheckResult import temporarily commented to fix TS6196 build error
import {
  // performHealthCheck, // TEMPORARILY COMMENTED OUT FOR BUILD: performHealthCheck import temporarily commented to fix TS6133 build error
  performEnhancedHealthCheck,
  getCurrentHealthStatus,
  detectEnvironment
} from '@/lib/database-health';
import { supabase } from '@/integrations/supabase/client';
import { createLogger as createEnvLogger, getEnvironmentConfig, /* environment, */ /* , performanceMonitor */ } from '@/lib/environment';
import { createShadowManifestation } from '@/data/shadowManifestations';
import { isLastScene } from '@/engine/scene-engine';
import {
  executePlayerAction,
  executeShadowAction,
  decideShadowAction,
  checkCombatEnd,
  canPerformAction,
  processStatusEffects
} from '@/engine/combat-engine';
import { soundManager } from '@/utils/sound-manager';
// TEMPORARILY COMMENTED OUT FOR BUILD: environment and performanceMonitor imports temporarily commented to fix TS6133 build error

// Save operation status types
export type SaveStatus = 'idle' | 'saving' | 'success' | 'error';

export interface SaveState {
  status: SaveStatus;
  lastSaveTimestamp?: number;
  lastError?: string;
  retryCount: number;
  hasUnsavedChanges: boolean;
}

// Error types for better error handling
export enum SaveErrorType {
  NETWORK_ERROR = 'NETWORK_ERROR',
  PERMISSION_ERROR = 'PERMISSION_ERROR',
  VALIDATION_ERROR = 'VALIDATION_ERROR',
  AUTHENTICATION_ERROR = 'AUTHENTICATION_ERROR',
  UNKNOWN_ERROR = 'UNKNOWN_ERROR'
}

export interface SaveError {
  type: SaveErrorType;
  message: string;
  originalError?: any;
  timestamp: number;
}

// Retry configuration
const RETRY_CONFIG = {
  maxAttempts: 3,
  baseDelay: 1000, // 1 second
  maxDelay: 10000, // 10 seconds
  backoffMultiplier: 2
};

// Use shared environment detection
// const getEnvironment = environment.current; // TEMPORARILY COMMENTED OUT FOR BUILD: getEnvironment variable temporarily commented to fix TS6133 build error

// Use shared environment-aware logger
const logger = createEnvLogger('GameStore');

// Error classification utility
const classifyError = (error: any): SaveErrorType => {
  if (!error) return SaveErrorType.UNKNOWN_ERROR;
  
  const message = error.message?.toLowerCase() || '';
  const code = error.code?.toLowerCase() || '';
  
  // Network-related errors
  if (message.includes('network') ||
      message.includes('timeout') ||
      message.includes('connection') ||
      message.includes('fetch') ||
      code.includes('network')) {
    return SaveErrorType.NETWORK_ERROR;
  }
  
  // Authentication errors
  if (message.includes('auth') ||
      message.includes('unauthorized') ||
      message.includes('forbidden') ||
      code === 'unauthorized' ||
      code === 'forbidden') {
    return SaveErrorType.AUTHENTICATION_ERROR;
  }
  
  // Permission errors
  if (message.includes('permission') ||
      message.includes('access denied') ||
      code.includes('permission')) {
    return SaveErrorType.PERMISSION_ERROR;
  }
  
  // Validation errors
  if (message.includes('validation') ||
      message.includes('constraint') ||
      message.includes('invalid') ||
      code.includes('constraint') ||
      code.includes('check')) {
    return SaveErrorType.VALIDATION_ERROR;
  }
  
  return SaveErrorType.UNKNOWN_ERROR;
};

// Determine if an error type is retryable
const isRetryableError = (errorType: SaveErrorType): boolean => {
  switch (errorType) {
    case SaveErrorType.NETWORK_ERROR:
      return true; // Network issues are often temporary
    case SaveErrorType.AUTHENTICATION_ERROR:
      return false; // Auth issues need user intervention
    case SaveErrorType.PERMISSION_ERROR:
      return false; // Permission issues need admin intervention
    case SaveErrorType.VALIDATION_ERROR:
      return false; // Data validation errors won't fix themselves
    case SaveErrorType.UNKNOWN_ERROR:
      return true; // Retry unknown errors in case they're transient
    default:
      return false;
  }
};

export interface Milestone {
  id: string;
  level: number;
  label: string;
  achieved: boolean;
  achievedAt?: number; // Use timestamp instead of Date
}

export interface CompletedScene {
  id: string;
  sceneId: string;
  type: 'social' | 'skill' | 'combat' | 'journal' | 'exploration';
  title: string;
  success: boolean;
  roll: number;
  dc: number;
  trustChange: number;
  completedAt: number; // Use timestamp instead of Date
}

// Light & Shadow Combat System Types
export interface LightShadowResources {
  lp: number;  // Light Points - Positive emotional resources
  sp: number;  // Shadow Points - Challenges that can become growth
}

export type CombatAction = 'ILLUMINATE' | 'REFLECT' | 'ENDURE' | 'EMBRACE';

export interface ShadowManifestation {
  id: string;
  name: string;
  type: 'doubt' | 'isolation' | 'overwhelm' | 'past-pain';
  description: string;
  currentHP: number;
  maxHP: number;
  abilities: ShadowAbility[];
  therapeuticInsight: string;
  victoryReward: {
    lpBonus: number;
    growthMessage: string;
    permanentBenefit: string;
  };
}

export interface ShadowAbility {
  id: string;
  name: string;
  cooldown: number;
  currentCooldown: number;
  effect: (state: CombatState) => void;
  description: string;
}

export interface CombatLogEntry {
  turn: number;
  actor: 'PLAYER' | 'SHADOW';
  action: string;
  effect: string;
  resourceChange: Partial<LightShadowResources> & { enemyHP?: number; healthDamage?: number };
  message: string;
}

export interface CombatState {
  inCombat: boolean;
  currentEnemy: ShadowManifestation | null;
  resources: LightShadowResources;
  turn: number;
  log: CombatLogEntry[];

  // Scene context for damage calculation
  sceneDC: number; // Difficulty check of the scene that triggered combat

  // Status effects
  damageMultiplier: number;
  damageReduction: number;
  healingBlocked: number;
  lpGenerationBlocked: number;
  skipNextTurn: boolean;
  consecutiveEndures: number;

  // Therapeutic tracking
  preferredActions: Record<CombatAction, number>;
  growthInsights: string[];
  combatReflections: JournalEntry[];
}

export interface GameState {
  guardianTrust: number;
  playerLevel: number;
  currentSceneIndex: number;
  journalEntries: JournalEntry[];
  milestones: Milestone[];
  sceneHistory: CompletedScene[];
  pendingMilestoneJournals: Set<number>;

  // Player Health System
  playerHealth: number; // 0-100, represents player's overall health
  maxPlayerHealth: number; // Maximum health capacity

  // Light & Shadow Combat Resources
  lightPoints: number;
  shadowPoints: number;

  // Combat System State
  combat: CombatState;

  // Save operation state
  saveState: SaveState;

  // Database health check state
  healthStatus: DatabaseHealthStatus;
  
  // Actions
  setGuardianTrust: (trust: number) => void;
  addJournalEntry: (entry: JournalEntry) => void;
  updateJournalEntry: (id: string, updates: Partial<JournalEntry>) => void;
  deleteJournalEntry: (id: string) => void;
  completeScene: (scene: CompletedScene) => void;
  advanceScene: () => void;
  saveToSupabase: () => Promise<void>;
  loadFromSupabase: () => Promise<void>;
  resetGame: () => void;
  updateMilestone: (level: number) => void;
  markMilestoneJournalShown: (level: number) => void;
  
  // Player Health Management
  modifyPlayerHealth: (delta: number) => void;
  healPlayerHealth: (amount: number) => void;
  setPlayerHealth: (health: number) => void;

  // Light & Shadow Combat Actions
  modifyLightPoints: (delta: number) => void;
  modifyShadowPoints: (delta: number) => void;
  convertShadowToLight: (amount: number) => void;

  // Combat System Actions
  startCombat: (enemyId: string, sceneDC?: number) => void;
  executeCombatAction: (action: CombatAction) => void;
  endTurn: () => void;
  endCombat: (victory: boolean) => void;
  
  // Save state utilities
  checkUnsavedChanges: () => boolean;
  clearSaveError: () => void;
  
  // Health check actions
  performHealthCheck: () => Promise<void>;
  startHealthMonitoring: () => void;
  stopHealthMonitoring: () => void;
  
  // Internal state (not persisted)
  _hasHydrated: boolean;
  _setHasHydrated: (hasHydrated: boolean) => void;
  _healthCheckInterval?: NodeJS.Timeout;
  _isHealthMonitoringActive: boolean;
}

const initialMilestones: Milestone[] = [
  { id: 'milestone-25', level: 25, label: 'Inner Strength', achieved: false },
  { id: 'milestone-50', level: 50, label: 'Finding Balance', achieved: false },
  { id: 'milestone-75', level: 75, label: 'Deep Connection', achieved: false },
];

export const useGameStoreBase = create<GameState>()(
  persist(
    (set, get) => ({
      // Initial state
      guardianTrust: 50,
      playerLevel: 1,
      currentSceneIndex: 0,
      journalEntries: [],
      milestones: initialMilestones,
      sceneHistory: [],
      pendingMilestoneJournals: new Set(),

      // Player Health System
      playerHealth: 100, // Start at full health
      maxPlayerHealth: 100, // Standard maximum health

      // Light & Shadow Combat Resources
      // Players start with some resources to enable combat functionality
      lightPoints: 10,
      shadowPoints: 5,

      // Combat System State
      combat: {
        inCombat: false,
        currentEnemy: null,
        resources: { lp: 0, sp: 0 },
        turn: 0,
        log: [],

        // Scene context
        sceneDC: 0, // Default DC when not in combat

        // Status effects
        damageMultiplier: 1,
        damageReduction: 1,
        healingBlocked: 0,
        lpGenerationBlocked: 0,
        skipNextTurn: false,
        consecutiveEndures: 0,

        // Therapeutic tracking
        preferredActions: {
          ILLUMINATE: 0,
          REFLECT: 0,
          ENDURE: 0,
          EMBRACE: 0
        },
        growthInsights: [],
        combatReflections: []
      },
      
      // Save operation state
      saveState: {
        status: 'idle',
        retryCount: 0,
        hasUnsavedChanges: false
      },
      
      // Database health check state
      healthStatus: {
        isConnected: false,
        responseTime: 0,
        lastChecked: 0,
        environment: detectEnvironment()
      },
      
      _hasHydrated: false,
      _isHealthMonitoringActive: false,

      // Actions
      setGuardianTrust: (trust: number) => {
        const clampedTrust = Math.max(0, Math.min(100, trust));
        set((state) => ({
          guardianTrust: clampedTrust,
          saveState: { ...state.saveState, hasUnsavedChanges: true }
        }));

        // Check for milestone achievements
        get().updateMilestone(clampedTrust);
      },

      addJournalEntry: (entry: JournalEntry) => {
        set((state) => {
          // Check for duplicate milestone entries
          if (entry.type === 'milestone') {
            const existingMilestone = state.journalEntries.find(
              (e) => e.type === 'milestone' && e.trustLevel === entry.trustLevel,
            );
            if (existingMilestone) {
              return state;
            }
          }

          const newEntries = [...state.journalEntries, entry];
          // No limit on journal entries - store them all
          return {
            journalEntries: newEntries,
            saveState: { ...state.saveState, hasUnsavedChanges: true }
          };
        });

        // Don't auto-save - let the app decide when to save
      },

      updateJournalEntry: (id: string, updates: Partial<JournalEntry>) => {
        set((state) => ({
          journalEntries: state.journalEntries.map((entry) =>
            entry.id === id
              ? { ...entry, ...updates, isEdited: true, editedAt: new Date() }
              : entry,
          ),
          saveState: { ...state.saveState, hasUnsavedChanges: true }
        }));

        // Don't auto-save - let the app decide when to save
      },

      deleteJournalEntry: (id: string) => {
        set((state) => ({
          journalEntries: state.journalEntries.filter((entry) => entry.id !== id),
          saveState: { ...state.saveState, hasUnsavedChanges: true }
        }));

        // Don't auto-save - let the app decide when to save
      },

      completeScene: (scene: CompletedScene) => {
        set((state) => ({
          sceneHistory: [...state.sceneHistory, scene],
          saveState: { ...state.saveState, hasUnsavedChanges: true }
        }));
      },

      advanceScene: () => {
        set((state) => ({
          currentSceneIndex: state.currentSceneIndex + 1,
          saveState: { ...state.saveState, hasUnsavedChanges: true }
        }));
      },

      updateMilestone: (trustLevel: number) => {
        set((state) => {
          // Check which milestones need to be achieved
          const milestonesToAchieve = state.milestones.filter(
            (milestone) => trustLevel >= milestone.level && !milestone.achieved
          );
          
          // If no milestones to achieve, return unchanged state
          if (milestonesToAchieve.length === 0) {
            return state; // Return same state reference - no change
          }
          
          // Check if we actually need to add new pending journals
          const levelsToAdd = milestonesToAchieve
            .map(m => m.level)
            .filter(level => !state.pendingMilestoneJournals.has(level));
          
          // If nothing new to add to pending journals, just update milestones
          if (levelsToAdd.length === 0) {
            const updatedMilestones = state.milestones.map((milestone) => {
              if (trustLevel >= milestone.level && !milestone.achieved) {
                return {
                  ...milestone,
                  achieved: true,
                  achievedAt: Date.now(),
                };
              }
              return milestone;
            });
            
            return {
              milestones: updatedMilestones,
              saveState: { ...state.saveState, hasUnsavedChanges: true }
            };
          }
          
          // Only create new Set if we're actually adding new levels
          const newPendingJournals = new Set(state.pendingMilestoneJournals);
          levelsToAdd.forEach(level => newPendingJournals.add(level));
          
          const updatedMilestones = state.milestones.map((milestone) => {
            if (trustLevel >= milestone.level && !milestone.achieved) {
              return {
                ...milestone,
                achieved: true,
                achievedAt: Date.now(),
              };
            }
            return milestone;
          });

          return {
            milestones: updatedMilestones,
            pendingMilestoneJournals: newPendingJournals,
            saveState: { ...state.saveState, hasUnsavedChanges: true }
          };
        });
      },

      markMilestoneJournalShown: (level: number) => {
        set((state) => {
          // Only update if the level exists in the pending set
          if (!state.pendingMilestoneJournals.has(level)) {
            return state; // Return same state reference - no change
          }
          
          // Create new Set and remove the level
          const newPendingJournals = new Set(state.pendingMilestoneJournals);
          newPendingJournals.delete(level);
          return { pendingMilestoneJournals: newPendingJournals };
        });
      },

      resetGame: () => {
        set((state) => ({
          guardianTrust: 50,
          playerLevel: 1,
          currentSceneIndex: 0,
          journalEntries: [],
          milestones: initialMilestones.map((m) => ({
            ...m,
            achieved: false,
            achievedAt: undefined,
          })),
          sceneHistory: [],
          pendingMilestoneJournals: new Set(),
          // Reset player health
          playerHealth: 100,
          maxPlayerHealth: 100,
          lightPoints: 0,
          shadowPoints: 0,
          // Reset combat state
          combat: {
            inCombat: false,
            currentEnemy: null,
            resources: { lp: 0, sp: 0 },
            turn: 0,
            log: [],

            // Scene context
            sceneDC: 0,

            // Status effects
            damageMultiplier: 1,
            damageReduction: 1,
            healingBlocked: 0,
            lpGenerationBlocked: 0,
            skipNextTurn: false,
            consecutiveEndures: 0,

            // Therapeutic tracking
            preferredActions: {
              ILLUMINATE: 0,
              REFLECT: 0,
              ENDURE: 0,
              EMBRACE: 0
            },
            growthInsights: [],
            combatReflections: []
          },
          saveState: { ...state.saveState, hasUnsavedChanges: true }
        }));
        // Also clear from storage to prevent rehydration of bad state
        localStorage.removeItem('luminari-game-state');
      },

      // Player Health Management
      modifyPlayerHealth: (delta: number) => {
        set((state) => {
          const newHealth = Math.max(0, Math.min(state.maxPlayerHealth, state.playerHealth + delta));
          logger.debug('Modified player health', {
            previous: state.playerHealth,
            delta,
            new: newHealth,
            max: state.maxPlayerHealth
          });
          return {
            playerHealth: newHealth,
            saveState: { ...state.saveState, hasUnsavedChanges: true }
          };
        });
      },

      healPlayerHealth: (amount: number) => {
        set((state) => {
          const healAmount = Math.max(0, amount);
          const newHealth = Math.min(state.maxPlayerHealth, state.playerHealth + healAmount);
          logger.debug('Healed player health', {
            previous: state.playerHealth,
            healAmount,
            new: newHealth,
            max: state.maxPlayerHealth
          });
          return {
            playerHealth: newHealth,
            saveState: { ...state.saveState, hasUnsavedChanges: true }
          };
        });
      },

      setPlayerHealth: (health: number) => {
        set((state) => {
          const newHealth = Math.max(0, Math.min(state.maxPlayerHealth, health));
          logger.debug('Set player health', {
            previous: state.playerHealth,
            new: newHealth,
            max: state.maxPlayerHealth
          });
          return {
            playerHealth: newHealth,
            saveState: { ...state.saveState, hasUnsavedChanges: true }
          };
        });
      },

      // Light & Shadow Combat Resource Management
      modifyLightPoints: (delta: number) => {
        set((state) => {
          const newLightPoints = Math.max(0, state.lightPoints + delta);
          logger.debug('Modified light points', { 
            previous: state.lightPoints, 
            delta, 
            new: newLightPoints 
          });
          return {
            lightPoints: newLightPoints,
            saveState: { ...state.saveState, hasUnsavedChanges: true }
          };
        });
      },

      modifyShadowPoints: (delta: number) => {
        set((state) => {
          const newShadowPoints = Math.max(0, state.shadowPoints + delta);
          logger.debug('Modified shadow points', { 
            previous: state.shadowPoints, 
            delta, 
            new: newShadowPoints 
          });
          return {
            shadowPoints: newShadowPoints,
            saveState: { ...state.saveState, hasUnsavedChanges: true }
          };
        });
      },

      convertShadowToLight: (amount: number) => {
        set((state) => {
          const shadowToConvert = Math.min(amount, state.shadowPoints);
          if (shadowToConvert === 0) {
            logger.warn('No shadow points to convert', {
              requested: amount,
              available: state.shadowPoints
            });
            return state;
          }

          const newShadowPoints = state.shadowPoints - shadowToConvert;
          const newLightPoints = state.lightPoints + shadowToConvert;

          logger.info('Converted shadow points to light', {
            converted: shadowToConvert,
            shadowPoints: { from: state.shadowPoints, to: newShadowPoints },
            lightPoints: { from: state.lightPoints, to: newLightPoints }
          });

          return {
            shadowPoints: newShadowPoints,
            lightPoints: newLightPoints,
            saveState: { ...state.saveState, hasUnsavedChanges: true }
          };
        });
      },

      // Combat System Actions
      startCombat: (enemyId: string, sceneDC?: number) => {
        set((state) => {
          const effectiveSceneDC = sceneDC || 12; // Default DC if not provided
          logger.info('Starting combat', { enemyId, sceneDC: effectiveSceneDC });

          // Create actual shadow manifestation using the shadow data system
          const shadowEnemy = createShadowManifestation(enemyId);

          if (!shadowEnemy) {
            logger.error('Failed to create shadow manifestation', { enemyId });
            // Fallback to prevent crash - this should not happen in normal gameplay
            return state;
          }

          logger.info('Shadow manifestation created', {
            shadowId: shadowEnemy.id,
            shadowName: shadowEnemy.name,
            shadowHP: shadowEnemy.maxHP,
            sceneDC: effectiveSceneDC
          });

          return {
            ...state,
            combat: {
              ...state.combat,
              inCombat: true,
              currentEnemy: shadowEnemy,
              resources: { lp: state.lightPoints, sp: state.shadowPoints },
              turn: 1,
              sceneDC: effectiveSceneDC,
              log: [{
                turn: 0,
                actor: 'SHADOW',
                action: 'MANIFEST',
                effect: 'Combat begins',
                resourceChange: {},
                message: `${shadowEnemy.name} emerges from the shadows of your mind...`
              }]
            },
            saveState: { ...state.saveState, hasUnsavedChanges: true }
          };
        });
      },

      executeCombatAction: (action: CombatAction) => {
        set((state) => {
          if (!state.combat.inCombat || !state.combat.currentEnemy) {
            logger.warn('Attempted combat action outside of combat', { action });
            return state;
          }

          logger.info('Executing combat action', { action, turn: state.combat.turn });

          // Validate action can be performed
          const validation = canPerformAction(action, state.combat, state.guardianTrust);
          if (!validation.canPerform) {
            logger.warn('Cannot perform combat action', { action, reason: validation.reason });
            return state;
          }

          // Execute player action using combat engine
          const playerResult = executePlayerAction(action, state.combat, state.guardianTrust);
          let newCombatState = { ...playerResult.newState };

          // Update preferred actions tracking (ensure immutability)
          const newPreferredActions = {
            ...newCombatState.preferredActions,
            [action]: (newCombatState.preferredActions[action] || 0) + 1
          };
          newCombatState = {
            ...newCombatState,
            preferredActions: newPreferredActions
          };

          // Add player action to combat log
          const combatLog = [...newCombatState.log, playerResult.logEntry];

          // Update the state after player action
          const stateAfterPlayerAction = {
            ...state,
            combat: {
              ...newCombatState,
              log: combatLog
            },
            saveState: { ...state.saveState, hasUnsavedChanges: true }
          };

          // Check if combat ended after player action
          const combatEndStatus = checkCombatEnd(newCombatState);
          if (combatEndStatus.isEnded) {
            get().endCombat(combatEndStatus.victory!);
            return stateAfterPlayerAction;
          }

          return stateAfterPlayerAction;
        });
      },

      endTurn: () => {
        set((state) => {
          if (!state.combat.inCombat || !state.combat.currentEnemy) {
            logger.warn('Attempted to end turn outside of combat');
            return state;
          }

          logger.info('Ending turn and initiating shadow action', { turn: state.combat.turn });

          let newCombatState = { ...state.combat };

          // Execute shadow action if enemy is still alive
          let healthDamageDealt = 0;
          if (newCombatState.currentEnemy && newCombatState.currentEnemy.currentHP > 0) {
            const shadowAction = decideShadowAction(newCombatState.currentEnemy, newCombatState);
            if (shadowAction) {
              const shadowResult = executeShadowAction(shadowAction, newCombatState, state.guardianTrust);
              newCombatState = { ...shadowResult.newState };
              healthDamageDealt = shadowResult.healthDamage;

              // Add shadow action to combat log
              newCombatState.log = [...newCombatState.log, shadowResult.logEntry];

              // Play shadow attack sound effect
              try {
                soundManager.playSound('shadow-attack', 2);
              } catch (error) {
                logger.warn('Failed to play shadow attack sound:', error);
              }
            }
          }

          // Process status effects at turn end
          newCombatState = processStatusEffects(newCombatState);

          // Increment turn counter
          newCombatState = {
            ...newCombatState,
            turn: newCombatState.turn + 1
          };

          // Apply health damage from shadow action
          const newPlayerHealth = Math.max(0, state.playerHealth - healthDamageDealt);

          // Log health damage if any was dealt
          if (healthDamageDealt > 0) {
            logger.info('Player took health damage from shadow action', {
              damage: healthDamageDealt,
              newHealth: newPlayerHealth,
              previousHealth: state.playerHealth
            });
          }

          // Final combat end check after shadow action
          const combatEndStatus = checkCombatEnd(newCombatState);
          if (combatEndStatus.isEnded) {
            get().endCombat(combatEndStatus.victory!);
          }

          return {
            combat: newCombatState,
            playerHealth: newPlayerHealth,
            saveState: { ...state.saveState, hasUnsavedChanges: true }
          };
        });
      },

      endCombat: (victory: boolean) => {
        set((state) => {
          if (!state.combat.inCombat) {
            logger.warn('Attempted to end combat when not in combat');
            return state;
          }

          logger.info('Ending combat', { victory, turns: state.combat.turn });

          // Sync combat resources back to main game state
          const finalLightPoints = state.combat.resources.lp;
          const finalShadowPoints = state.combat.resources.sp;

          // Add victory rewards if applicable
          let bonusLP = 0;
          if (victory && state.combat.currentEnemy) {
            bonusLP = state.combat.currentEnemy.victoryReward.lpBonus;
          }

          // Create final combat log entry
          const finalLogEntry: CombatLogEntry = {
            turn: state.combat.turn,
            actor: victory ? 'PLAYER' : 'SHADOW',
            action: victory ? 'VICTORY' : 'DEFEAT',
            effect: victory ? 'Combat won' : 'Combat lost',
            resourceChange: { lp: bonusLP },
            message: victory
              ? 'You have overcome this shadow and grown stronger!'
              : 'Though defeated, you have learned valuable lessons...'
          };

          // Advance scene after successful combat (victory or learning from defeat)
          const shouldAdvanceScene = victory || !victory; // Always advance after combat
          const newSceneIndex = shouldAdvanceScene && !isLastScene(state.currentSceneIndex)
            ? state.currentSceneIndex + 1
            : state.currentSceneIndex;

          return {
            lightPoints: finalLightPoints + bonusLP,
            shadowPoints: finalShadowPoints,
            currentSceneIndex: newSceneIndex,
            combat: {
              inCombat: false,
              currentEnemy: null,
              resources: { lp: 0, sp: 0 },
              turn: 0,
              log: [...state.combat.log, finalLogEntry],

              // Reset scene context
              sceneDC: 0,

              // Reset status effects
              damageMultiplier: 1,
              damageReduction: 1,
              healingBlocked: 0,
              lpGenerationBlocked: 0,
              skipNextTurn: false,
              consecutiveEndures: 0,

              // Keep therapeutic tracking
              preferredActions: state.combat.preferredActions,
              growthInsights: state.combat.growthInsights,
              combatReflections: state.combat.combatReflections
            },
            saveState: { ...state.saveState, hasUnsavedChanges: true }
          };
        });
      },

      _setHasHydrated: (hasHydrated: boolean) => {
        set({ _hasHydrated: hasHydrated });
      },

      // Save state utilities
      checkUnsavedChanges: () => {
        const state = get();
        return state.saveState.hasUnsavedChanges ||
               state.saveState.status === 'error' ||
               state.saveState.lastSaveTimestamp === undefined;
      },

      clearSaveError: () => {
        set((state) => ({
          saveState: {
            ...state.saveState,
            status: 'idle',
            lastError: undefined,
            retryCount: 0
          }
        }));
      },

      saveToSupabase: async () => {
        const state = get();
        
        // Don't save if already saving or no user is authenticated
        if (state.saveState.status === 'saving') {
          logger.debug('Save already in progress, skipping');
          return;
        }

        // Get current user before starting save process
        try {
          const { data: { user }, error: userError } = await supabase.auth.getUser();
          
          if (userError || !user) {
            logger.warn('No authenticated user, skipping save', userError);
            set((state) => ({
              saveState: {
                ...state.saveState,
                status: 'error',
                lastError: userError?.message || 'No authenticated user',
                hasUnsavedChanges: true
              }
            }));
            return;
          }
        } catch (error) {
          logger.error('Error checking authentication before save', error);
          return;
        }

        const attemptSave = async (attempt: number = 1): Promise<void> => {
          try {
            // Update save state to saving
            set((state) => ({
              saveState: {
                ...state.saveState,
                status: 'saving',
                retryCount: attempt - 1
              }
            }));

            logger.debug(`Save attempt ${attempt}/${RETRY_CONFIG.maxAttempts}`);

            const { data: { user }, error: userError } = await supabase.auth.getUser();

            if (userError || !user) {
              logger.error('Authentication error during save', userError);
              throw {
                type: SaveErrorType.AUTHENTICATION_ERROR,
                message: userError?.message || 'No user authenticated - cannot save game state',
                originalError: userError
              };
            }

            const currentState = get();
            const startTime = Date.now();

            // Prepare game state data
            // Ensure all data is properly formatted for database
            const gameState: any = {
              user_id: user.id,
              guardian_trust: currentState.guardianTrust,
              player_level: currentState.playerLevel,
              current_scene_index: currentState.currentSceneIndex,
              milestones: JSON.stringify(currentState.milestones),
              scene_history: JSON.stringify(currentState.sceneHistory),
              updated_at: new Date().toISOString(),
            };

            logger.debug('Saving game state', {
              userId: user.id,
              guardianTrust: gameState.guardian_trust,
              journalCount: currentState.journalEntries.length
            });

            // Save game state with timeout
            const { data: savedState, error: stateError } = await Promise.race([
              supabase.from('game_states').upsert(gameState, { onConflict: 'user_id' }).select(),
              new Promise((_, reject) =>
                setTimeout(() => reject(new Error('Save timeout')), 30000)
              )
            ]) as any;

            if (stateError) {
              logger.error('Failed to save game state', stateError);
              throw {
                type: classifyError(stateError),
                message: `Failed to save game state: ${stateError.message}`,
                originalError: stateError
              };
            }
            
            logger.debug('Game state saved successfully', savedState);

            // Save journal entries if any exist
            if (currentState.journalEntries.length > 0) {
              // Format journal entries for database
              const journalEntries = currentState.journalEntries.map((entry) => {
                // Ensure timestamp is an ISO string
                const timestamp = entry.timestamp instanceof Date 
                  ? entry.timestamp.toISOString() 
                  : entry.timestamp;
                
                // Ensure editedAt is an ISO string if it exists
                const editedAt = entry.editedAt instanceof Date 
                  ? entry.editedAt.toISOString() 
                  : entry.editedAt;
                
                return {
                id: entry.id,
                user_id: user.id,
                type: entry.type,
                trust_level: entry.trustLevel,
                content: entry.content,
                title: entry.title,
                scene_id: entry.sceneId || null,
                tags: Array.isArray(entry.tags) ? entry.tags : [],
                is_edited: entry.isEdited || false,
                created_at: timestamp,
                edited_at: editedAt || null,
                };
              });

              logger.debug('Saving journal entries', { 
                count: journalEntries.length,
                firstEntry: journalEntries[0]?.id
              });

              const { data: savedEntries, error: journalError } = await Promise.race([
                supabase.from('journal_entries').upsert(journalEntries, { onConflict: 'id' }).select(),
                new Promise((_, reject) =>
                  setTimeout(() => reject(new Error('Journal save timeout')), 30000)
                )
              ]) as any;

              if (journalError) {
                logger.error('Failed to save journal entries', journalError);
                throw {
                  type: classifyError(journalError),
                  message: `Failed to save journal entries: ${journalError.message}`,
                  originalError: journalError
                };
              }
              
              logger.debug('Journal entries saved successfully', { 
                count: savedEntries?.length || 0 
              });
            }

            const saveTime = Date.now() - startTime;
            logger.info('Game state saved successfully', {
              saveTime: `${saveTime}ms`,
              attempt,
              journalCount: currentState.journalEntries.length
            });

            // Update save state to success
            set((state) => ({
              saveState: {
                ...state.saveState,
                status: 'success',
                lastSaveTimestamp: Date.now(),
                lastError: undefined,
                retryCount: 0,
                hasUnsavedChanges: false
              }
            }));

          } catch (error: any) {
            const saveError: SaveError = {
              type: error.type || SaveErrorType.UNKNOWN_ERROR,
              message: error.message || 'Unknown save error',
              originalError: error.originalError || error,
              timestamp: Date.now()
            };

            const {
              data: { user },
            } = await supabase.auth.getUser();
            
            logger.error('Save attempt failed', saveError, {
              attempt,
              userId: user?.id || 'unknown'
            });

            // Determine if we should retry
            const shouldRetry = attempt < RETRY_CONFIG.maxAttempts &&
                              isRetryableError(saveError.type);

            if (shouldRetry) {
              const delay = Math.min(
                RETRY_CONFIG.baseDelay * Math.pow(RETRY_CONFIG.backoffMultiplier, attempt - 1),
                RETRY_CONFIG.maxDelay
              );
              
              logger.info(`Retrying save in ${delay}ms`, { attempt: attempt + 1 });
              
              // Wait before retry
              await new Promise(resolve => setTimeout(resolve, delay));
              
              // Recursive retry
              return attemptSave(attempt + 1);
            } else {
              // Max attempts reached or non-retryable error
              logger.error('Save failed permanently', saveError, {
                maxAttemptsReached: attempt >= RETRY_CONFIG.maxAttempts,
                isRetryable: isRetryableError(saveError.type)
              });

              // Update save state to error
              set((state) => ({
                saveState: {
                  ...state.saveState,
                  status: 'error',
                  lastError: saveError.message,
                  retryCount: attempt,
                  hasUnsavedChanges: true
                }
              }));

              // Don't throw - we want the game to continue even if save fails
            }
          }
        };

        await attemptSave();
      },

      loadFromSupabase: async () => {
        try {
          const { data: { user }, error: userError } = await supabase.auth.getUser();

          if (userError || !user) {
            logger.warn('No user authenticated - skipping load', userError);
            return;
          }

          logger.debug('Loading game state for user', { userId: user.id });

          // Load game state
          const { data: gameState, error: stateError } = await supabase
            .from('game_states')
            .select('*')
            .eq('user_id', user.id)
            .single();

          if (stateError && stateError.code !== 'PGRST116') {
            // PGRST116 = no rows
            logger.error('Error loading game state:', stateError);
            throw stateError;
          }

          logger.debug('Game state loaded', { 
            found: !!gameState,
            guardianTrust: gameState?.guardian_trust || 0
          });

          // Load journal entries
          const { data: journalEntries, error: journalError } = await supabase
            .from('journal_entries')
            .select('*')
            .eq('user_id', user.id)
            .order('created_at', { ascending: false });

          if (journalError) {
            logger.error('Error loading journal entries:', journalError);
            throw journalError;
          }

          logger.debug('Journal entries loaded', { 
            count: journalEntries?.length || 0
          });

          if (gameState || journalEntries) {
            // Parse JSON fields from database
            const parsedMilestones = gameState?.milestones 
              ? (typeof gameState.milestones === 'string' 
                  ? JSON.parse(gameState.milestones) 
                  : gameState.milestones)
              : initialMilestones;
              
            const parsedSceneHistory = gameState?.scene_history
              ? (typeof gameState.scene_history === 'string'
                  ? JSON.parse(gameState.scene_history)
                  : gameState.scene_history)
              : [];

            set({
              ...(gameState && {
                guardianTrust: gameState.guardian_trust,
                playerLevel: gameState.player_level,
                currentSceneIndex: gameState.current_scene_index,
                milestones: parsedMilestones,
                sceneHistory: parsedSceneHistory,
              }),
              journalEntries:
                journalEntries?.map((entry) => ({
                  id: entry.id,
                  type: entry.type as 'milestone' | 'learning',
                  trustLevel: entry.trust_level,
                  content: entry.content,
                  title: entry.title,
                  timestamp: entry.created_at ? new Date(entry.created_at) : new Date(),
                  sceneId: entry.scene_id || undefined,
                  tags: Array.isArray(entry.tags) ? entry.tags.filter((tag): tag is string => typeof tag === 'string') : [],
                  isEdited: entry.is_edited || false,
                  editedAt: entry.edited_at ? new Date(entry.edited_at) : undefined,
                } as JournalEntry)) || [],
                saveState: {
                  status: 'success',
                  lastSaveTimestamp: Date.now(),
                  retryCount: 0,
                  hasUnsavedChanges: false
                }
            });

            logger.info('Game state loaded from Supabase successfully', {
              guardianTrust: gameState?.guardian_trust || 0,
              journalCount: journalEntries?.length || 0
            });
          }
        } catch (error) {
          logger.error('Failed to load from Supabase:', error);
          
          // Update save state to reflect error
          set((state) => ({
            saveState: {
              ...state.saveState,
              status: 'error',
              lastError: error instanceof Error ? error.message : 'Unknown error loading from Supabase',
              hasUnsavedChanges: true
            }
          }));
          
          // Don't throw - we want the game to continue even if load fails
        }
      },

      // Health check methods
      performHealthCheck: async () => {
        try {
          logger.debug('Performing database health check');
          
          const result = await performEnhancedHealthCheck();
          const newHealthStatus = getCurrentHealthStatus(result);
          
          set((_state) => ({
            // TEMPORARILY COMMENTED OUT FOR BUILD: state parameter renamed to _state to fix TS6133 build error
            healthStatus: newHealthStatus
          }));
          
          if (result.success) {
            logger.debug('Health check successful', {
              responseTime: result.responseTime,
              environment: newHealthStatus.environment
            });
          } else {
            logger.warn('Health check failed', {
              error: result.error,
              responseTime: result.responseTime
            });
          }
        } catch (error: any) {
          logger.error('Health check threw exception', error);
          
          set((_state) => ({
            // TEMPORARILY COMMENTED OUT FOR BUILD: state parameter renamed to _state to fix TS6133 build error
            healthStatus: {
              isConnected: false,
              responseTime: 0,
              lastChecked: Date.now(),
              error: error.message || 'Health check failed',
              environment: detectEnvironment()
            }
          }));
        }
      },

      startHealthMonitoring: () => {
        const state = get();
        
        // Don't start monitoring if already running
        if (state._isHealthMonitoringActive || state._healthCheckInterval) {
          logger.debug('Health monitoring already running');
          return;
        }
        
        logger.info('Starting database health monitoring');
        
        // Mark as active immediately to prevent race conditions
        set({ _isHealthMonitoringActive: true });
        
        // Perform initial health check
        get().performHealthCheck();
        
        // Set up periodic health checks using environment-specific interval
        const config = getEnvironmentConfig();
        const interval = setInterval(() => {
          const currentState = get();

          // Only perform health check if the app is active and user is present
          if (document.hidden || !document.hasFocus()) {
            logger.debug('Skipping health check - app not active');
            return;
          }

          currentState.performHealthCheck();
        }, config.healthCheckInterval);
        
        // Store interval reference
        set({ _healthCheckInterval: interval });
      },

      stopHealthMonitoring: () => {
        const state = get();
        
        if (state._healthCheckInterval) {
          logger.info('Stopping database health monitoring');
          clearInterval(state._healthCheckInterval);
          set({ 
            _healthCheckInterval: undefined,
            _isHealthMonitoringActive: false 
          });
        }
      },
    }),
    {
      name: 'luminari-game-state',
      partialize: (state) => ({
        guardianTrust: state.guardianTrust,
        playerLevel: state.playerLevel,
        currentSceneIndex: state.currentSceneIndex,
        journalEntries: state.journalEntries.map((entry) => ({
          ...entry,
          timestamp: entry.timestamp.toISOString(),
        })),
        milestones: state.milestones.map((milestone) => ({
          ...milestone,
          achievedAt: milestone.achievedAt
            ? new Date(milestone.achievedAt).toISOString()
            : undefined,
        })),
        sceneHistory: state.sceneHistory.map((scene) => ({
          ...scene,
          completedAt: new Date(scene.completedAt).toISOString(),
        })),
      }),
      // Add a merge function to handle rehydration
      merge: (persistedState: any, currentState) => {
        if (!persistedState) return currentState;

        // Convert ISO strings back to Date objects
        const hydratedJournalEntries = (persistedState.journalEntries || []).map((entry: any) => ({
          ...entry,
          timestamp: new Date(entry.timestamp),
        }));

        // Properly merge milestones, ensuring we don't duplicate and maintain initial structure
        const mergedMilestones = initialMilestones.map((initialMilestone) => {
          const persistedMilestone = (persistedState.milestones || []).find(
            (m: any) => m.id === initialMilestone.id,
          );
          return persistedMilestone
            ? {
                ...initialMilestone,
                ...persistedMilestone,
                achievedAt: persistedMilestone.achievedAt
                  ? new Date(persistedMilestone.achievedAt).getTime()
                  : undefined,
              }
            : initialMilestone;
        });

        return {
          ...currentState,
          ...persistedState,
          journalEntries: hydratedJournalEntries,
          milestones: mergedMilestones,
        };
      },
      onRehydrateStorage: () => (state) => {
        state?._setHasHydrated(true);
      },
    },
  ),
);

// Hydration-safe hook that prevents mismatches
export const useGameStore = () => {
  const store = useGameStoreBase();
  const [hasMounted, setHasMounted] = useState(false);

  useEffect(() => {
    setHasMounted(true);
  }, []);

  // Return initial values during SSR/hydration to prevent mismatches
  // BUT allow real-time resource values to show through for combat system
  if (!hasMounted || !store._hasHydrated) {
    return {
      guardianTrust: 50,
      playerLevel: 1,
      currentSceneIndex: 0,
      journalEntries: [],
      milestones: initialMilestones,
      sceneHistory: [],
      pendingMilestoneJournals: new Set(),

      // Player Health System - Use actual store values for real-time updates
      playerHealth: store.playerHealth,
      maxPlayerHealth: store.maxPlayerHealth,

      // Light & Shadow Combat Resources - Use actual store values for real-time updates
      lightPoints: store.lightPoints,
      shadowPoints: store.shadowPoints,

      // Combat System State - Use actual store values for real-time updates
      combat: store.combat,

      saveState: {
        status: 'idle',
        retryCount: 0,
        hasUnsavedChanges: false
      } as SaveState,
      healthStatus: {
        isConnected: false,
        responseTime: 0,
        lastChecked: 0,
        environment: detectEnvironment()
      } as DatabaseHealthStatus,
      setGuardianTrust: store.setGuardianTrust,
      addJournalEntry: store.addJournalEntry,
      updateJournalEntry: store.updateJournalEntry,
      deleteJournalEntry: store.deleteJournalEntry,
      completeScene: store.completeScene,
      advanceScene: store.advanceScene,
      saveToSupabase: store.saveToSupabase,
      loadFromSupabase: store.loadFromSupabase,
      resetGame: store.resetGame,
      updateMilestone: store.updateMilestone,
      markMilestoneJournalShown: store.markMilestoneJournalShown,

      // Player Health Management
      modifyPlayerHealth: store.modifyPlayerHealth,
      healPlayerHealth: store.healPlayerHealth,
      setPlayerHealth: store.setPlayerHealth,

      // Light & Shadow Combat Actions
      modifyLightPoints: store.modifyLightPoints,
      modifyShadowPoints: store.modifyShadowPoints,
      convertShadowToLight: store.convertShadowToLight,

      // Combat System Actions
      startCombat: store.startCombat,
      executeCombatAction: store.executeCombatAction,
      endTurn: store.endTurn,
      endCombat: store.endCombat,

      checkUnsavedChanges: store.checkUnsavedChanges,
      clearSaveError: store.clearSaveError,
      performHealthCheck: store.performHealthCheck,
      startHealthMonitoring: store.startHealthMonitoring,
      stopHealthMonitoring: store.stopHealthMonitoring,
      _hasHydrated: false,
      _setHasHydrated: store._setHasHydrated,
    };
  }

  return store;
};