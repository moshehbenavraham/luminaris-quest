// GENERATED BY BOLT.NEW â€“ DO NOT EDIT MANUALLY

import { create } from 'zustand';
import { persist } from 'zustand/middleware';
import { useEffect, useState } from 'react';
import type { JournalEntry } from '@/components/JournalModal';

export interface Milestone {
  id: string;
  level: number;
  label: string;
  achieved: boolean;
  achievedAt?: number; // Use timestamp instead of Date
}

export interface CompletedScene {
  id: string;
  sceneId: string;
  type: 'social' | 'skill' | 'combat' | 'journal' | 'exploration';
  title: string;
  success: boolean;
  roll: number;
  dc: number;
  trustChange: number;
  completedAt: number; // Use timestamp instead of Date
}

export interface GameState {
  guardianTrust: number;
  playerLevel: number;
  currentSceneIndex: number;
  journalEntries: JournalEntry[];
  milestones: Milestone[];
  sceneHistory: CompletedScene[];
  setGuardianTrust: (trust: number) => void;
  addJournalEntry: (entry: JournalEntry) => void;
  completeScene: (scene: CompletedScene) => void;
  advanceScene: () => void;
  saveToSupabase: () => Promise<void>;
  loadFromSupabase: () => Promise<void>;
  resetGame: () => void;
  updateMilestone: (level: number) => void;
  _hasHydrated: boolean;
  _setHasHydrated: (hasHydrated: boolean) => void;
}

const initialMilestones: Milestone[] = [
  { id: 'milestone-25', level: 25, label: 'Inner Strength', achieved: false },
  { id: 'milestone-50', level: 50, label: 'Finding Balance', achieved: false },
  { id: 'milestone-75', level: 75, label: 'Deep Connection', achieved: false },
];

const useGameStoreBase = create<GameState>()(
  persist(
    (set, get) => ({
      // Initial state
      guardianTrust: 50,
      playerLevel: 1,
      currentSceneIndex: 0,
      journalEntries: [],
      milestones: initialMilestones,
      sceneHistory: [],
      _hasHydrated: false,

      // Actions
      setGuardianTrust: (trust: number) => {
        const clampedTrust = Math.max(0, Math.min(100, trust));
        set({ guardianTrust: clampedTrust });
        
        // Check for milestone achievements
        get().updateMilestone(clampedTrust);
      },

      addJournalEntry: (entry: JournalEntry) => {
        set((state) => {
          const newEntries = [...state.journalEntries, entry];
          // Keep only the most recent 12 entries
          const limitedEntries = newEntries
            .sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime())
            .slice(0, 12);
          
          return {
            journalEntries: limitedEntries,
          };
        });
      },

      completeScene: (scene: CompletedScene) => {
        set((state) => ({
          sceneHistory: [...state.sceneHistory, scene],
        }));
      },

      advanceScene: () => {
        set((state) => ({
          currentSceneIndex: state.currentSceneIndex + 1,
        }));
      },

      updateMilestone: (trustLevel: number) => {
        set((state) => {
          const updatedMilestones = state.milestones.map((milestone) => {
            if (trustLevel >= milestone.level && !milestone.achieved) {
              return {
                ...milestone,
                achieved: true,
                achievedAt: Date.now(),
              };
            }
            return milestone;
          });

          // Deduplicate milestones to prevent runaway state growth from old bugs
          const uniqueMilestones = updatedMilestones.filter(
            (milestone, index, self) =>
              index === self.findIndex((m) => m.id === milestone.id)
          );

          return { milestones: uniqueMilestones };
        });
      },

      resetGame: () => {
        set({
          guardianTrust: 50,
          playerLevel: 1,
          currentSceneIndex: 0,
          journalEntries: [],
          milestones: initialMilestones.map(m => ({...m, achieved: false, achievedAt: undefined })),
          sceneHistory: [],
        });
        // Also clear from storage to prevent rehydration of bad state
        localStorage.removeItem('luminari-game-state');
      },

      _setHasHydrated: (hasHydrated: boolean) => {
        set({ _hasHydrated: hasHydrated });
      },

      // Placeholder implementations for Supabase integration
      saveToSupabase: async () => {
        // TODO: Implement Supabase save functionality
        // This will save the current game state to the user's profile
        console.log('Saving game state to Supabase...', get());
        return Promise.resolve();
      },

      loadFromSupabase: async () => {
        // TODO: Implement Supabase load functionality
        // This will load the user's saved game state from their profile
        console.log('Loading game state from Supabase...');
        return Promise.resolve();
      },
    }),
    {
      name: 'luminari-game-state',
      partialize: (state) => ({
        guardianTrust: state.guardianTrust,
        playerLevel: state.playerLevel,
        currentSceneIndex: state.currentSceneIndex,
        journalEntries: state.journalEntries.map(entry => ({
          ...entry,
          timestamp: entry.timestamp.toISOString()
        })),
        milestones: state.milestones.map(milestone => ({
          ...milestone,
          achievedAt: milestone.achievedAt ? new Date(milestone.achievedAt).toISOString() : undefined
        })),
        sceneHistory: state.sceneHistory.map(scene => ({
          ...scene,
          completedAt: new Date(scene.completedAt).toISOString()
        })),
      }),
      // Add a merge function to handle rehydration
      merge: (persistedState: any, currentState) => {
        if (!persistedState) return currentState;
        
        // Convert ISO strings back to Date objects
        const hydratedJournalEntries = (persistedState.journalEntries || []).map((entry: any) => ({
          ...entry,
          timestamp: new Date(entry.timestamp)
        }));
        
        // Properly merge milestones, ensuring we don't duplicate and maintain initial structure
        const mergedMilestones = initialMilestones.map(initialMilestone => {
          const persistedMilestone = (persistedState.milestones || []).find(
            (m: any) => m.id === initialMilestone.id
          );
          return persistedMilestone ? {
            ...initialMilestone,
            ...persistedMilestone,
            achievedAt: persistedMilestone.achievedAt ? new Date(persistedMilestone.achievedAt).getTime() : undefined
          } : initialMilestone;
        });
        
        return {
          ...currentState,
          ...persistedState,
          journalEntries: hydratedJournalEntries,
          milestones: mergedMilestones,
        };
      },
      onRehydrateStorage: () => (state) => {
        state?._setHasHydrated(true);
      },
    }
  )
);

// Hydration-safe hook that prevents mismatches
export const useGameStore = () => {
  const store = useGameStoreBase();
  const [hasMounted, setHasMounted] = useState(false);

  useEffect(() => {
    setHasMounted(true);
  }, []);

  // Return initial values during SSR/hydration to prevent mismatches
  if (!hasMounted || !store._hasHydrated) {
    return {
      guardianTrust: 50,
      playerLevel: 1,
      currentSceneIndex: 0,
      journalEntries: [],
      milestones: initialMilestones,
      sceneHistory: [],
      setGuardianTrust: store.setGuardianTrust,
      addJournalEntry: store.addJournalEntry,
      completeScene: store.completeScene,
      advanceScene: store.advanceScene,
      saveToSupabase: store.saveToSupabase,
      loadFromSupabase: store.loadFromSupabase,
      resetGame: store.resetGame,
      updateMilestone: store.updateMilestone,
      _hasHydrated: false,
      _setHasHydrated: store._setHasHydrated,
    };
  }

  return store;
};