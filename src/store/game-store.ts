// GENERATED BY BOLT.NEW â€“ DO NOT EDIT MANUALLY

import { create } from 'zustand';
import { persist } from 'zustand/middleware';
import { useEffect, useState } from 'react';
import type { JournalEntry } from '@/components/JournalModal';
import type { DatabaseHealthStatus /* , DatabaseHealthCheckResult */ } from '@/lib/database-health';
// TEMPORARILY COMMENTED OUT FOR BUILD: DatabaseHealthCheckResult import temporarily commented to fix TS6196 build error
import {
  // performHealthCheck, // TEMPORARILY COMMENTED OUT FOR BUILD: performHealthCheck import temporarily commented to fix TS6133 build error
  performEnhancedHealthCheck,
  getCurrentHealthStatus,
  detectEnvironment
} from '@/lib/database-health';
import { createLogger as createEnvLogger, /* environment, */ /* , performanceMonitor */ } from '@/lib/environment';
// TEMPORARILY COMMENTED OUT FOR BUILD: environment and performanceMonitor imports temporarily commented to fix TS6133 build error

// Save operation status types
export type SaveStatus = 'idle' | 'saving' | 'success' | 'error';

export interface SaveState {
  status: SaveStatus;
  lastSaveTimestamp?: number;
  lastError?: string;
  retryCount: number;
  hasUnsavedChanges: boolean;
}

// Error types for better error handling
export enum SaveErrorType {
  NETWORK_ERROR = 'NETWORK_ERROR',
  PERMISSION_ERROR = 'PERMISSION_ERROR',
  VALIDATION_ERROR = 'VALIDATION_ERROR',
  AUTHENTICATION_ERROR = 'AUTHENTICATION_ERROR',
  UNKNOWN_ERROR = 'UNKNOWN_ERROR'
}

export interface SaveError {
  type: SaveErrorType;
  message: string;
  originalError?: any;
  timestamp: number;
}

// Retry configuration
const RETRY_CONFIG = {
  maxAttempts: 3,
  baseDelay: 1000, // 1 second
  maxDelay: 10000, // 10 seconds
  backoffMultiplier: 2
};

// Use shared environment detection
// const getEnvironment = environment.current; // TEMPORARILY COMMENTED OUT FOR BUILD: getEnvironment variable temporarily commented to fix TS6133 build error

// Use shared environment-aware logger
const logger = createEnvLogger('GameStore');

// Error classification utility
const classifyError = (error: any): SaveErrorType => {
  if (!error) return SaveErrorType.UNKNOWN_ERROR;
  
  const message = error.message?.toLowerCase() || '';
  const code = error.code?.toLowerCase() || '';
  
  // Network-related errors
  if (message.includes('network') ||
      message.includes('timeout') ||
      message.includes('connection') ||
      message.includes('fetch') ||
      code.includes('network')) {
    return SaveErrorType.NETWORK_ERROR;
  }
  
  // Authentication errors
  if (message.includes('auth') ||
      message.includes('unauthorized') ||
      message.includes('forbidden') ||
      code === 'unauthorized' ||
      code === 'forbidden') {
    return SaveErrorType.AUTHENTICATION_ERROR;
  }
  
  // Permission errors
  if (message.includes('permission') ||
      message.includes('access denied') ||
      code.includes('permission')) {
    return SaveErrorType.PERMISSION_ERROR;
  }
  
  // Validation errors
  if (message.includes('validation') ||
      message.includes('constraint') ||
      message.includes('invalid') ||
      code.includes('constraint') ||
      code.includes('check')) {
    return SaveErrorType.VALIDATION_ERROR;
  }
  
  return SaveErrorType.UNKNOWN_ERROR;
};

// Determine if an error type is retryable
const isRetryableError = (errorType: SaveErrorType): boolean => {
  switch (errorType) {
    case SaveErrorType.NETWORK_ERROR:
      return true; // Network issues are often temporary
    case SaveErrorType.AUTHENTICATION_ERROR:
      return false; // Auth issues need user intervention
    case SaveErrorType.PERMISSION_ERROR:
      return false; // Permission issues need admin intervention
    case SaveErrorType.VALIDATION_ERROR:
      return false; // Data validation errors won't fix themselves
    case SaveErrorType.UNKNOWN_ERROR:
      return true; // Retry unknown errors in case they're transient
    default:
      return false;
  }
};

export interface Milestone {
  id: string;
  level: number;
  label: string;
  achieved: boolean;
  achievedAt?: number; // Use timestamp instead of Date
}

export interface CompletedScene {
  id: string;
  sceneId: string;
  type: 'social' | 'skill' | 'combat' | 'journal' | 'exploration';
  title: string;
  success: boolean;
  roll: number;
  dc: number;
  trustChange: number;
  completedAt: number; // Use timestamp instead of Date
}

export interface GameState {
  guardianTrust: number;
  playerLevel: number;
  currentSceneIndex: number;
  journalEntries: JournalEntry[];
  milestones: Milestone[];
  sceneHistory: CompletedScene[];
  pendingMilestoneJournals: Set<number>;
  
  // Save operation state
  saveState: SaveState;
  
  // Database health check state
  healthStatus: DatabaseHealthStatus;
  
  // Actions
  setGuardianTrust: (trust: number) => void;
  addJournalEntry: (entry: JournalEntry) => void;
  updateJournalEntry: (id: string, updates: Partial<JournalEntry>) => void;
  deleteJournalEntry: (id: string) => void;
  completeScene: (scene: CompletedScene) => void;
  advanceScene: () => void;
  saveToSupabase: () => Promise<void>;
  loadFromSupabase: () => Promise<void>;
  resetGame: () => void;
  updateMilestone: (level: number) => void;
  markMilestoneJournalShown: (level: number) => void;
  
  // Save state utilities
  checkUnsavedChanges: () => boolean;
  clearSaveError: () => void;
  
  // Health check actions
  performHealthCheck: () => Promise<void>;
  startHealthMonitoring: () => void;
  stopHealthMonitoring: () => void;
  
  // Internal state (not persisted)
  _hasHydrated: boolean;
  _setHasHydrated: (hasHydrated: boolean) => void;
  _healthCheckInterval?: NodeJS.Timeout;
  _isHealthMonitoringActive: boolean;
}

const initialMilestones: Milestone[] = [
  { id: 'milestone-25', level: 25, label: 'Inner Strength', achieved: false },
  { id: 'milestone-50', level: 50, label: 'Finding Balance', achieved: false },
  { id: 'milestone-75', level: 75, label: 'Deep Connection', achieved: false },
];

const useGameStoreBase = create<GameState>()(
  persist(
    (set, get) => ({
      // Initial state
      guardianTrust: 50,
      playerLevel: 1,
      currentSceneIndex: 0,
      journalEntries: [],
      milestones: initialMilestones,
      sceneHistory: [],
      pendingMilestoneJournals: new Set(),
      
      // Save operation state
      saveState: {
        status: 'idle',
        retryCount: 0,
        hasUnsavedChanges: false
      },
      
      // Database health check state
      healthStatus: {
        isConnected: false,
        responseTime: 0,
        lastChecked: 0,
        environment: detectEnvironment()
      },
      
      _hasHydrated: false,
      _isHealthMonitoringActive: false,

      // Actions
      setGuardianTrust: (trust: number) => {
        const clampedTrust = Math.max(0, Math.min(100, trust));
        set((state) => ({
          guardianTrust: clampedTrust,
          saveState: { ...state.saveState, hasUnsavedChanges: true }
        }));

        // Check for milestone achievements
        get().updateMilestone(clampedTrust);
      },

      addJournalEntry: (entry: JournalEntry) => {
        set((state) => {
          // Check for duplicate milestone entries
          if (entry.type === 'milestone') {
            const existingMilestone = state.journalEntries.find(
              (e) => e.type === 'milestone' && e.trustLevel === entry.trustLevel,
            );
            if (existingMilestone) {
              console.warn('Duplicate milestone journal entry prevented');
              return state;
            }
          }

          const newEntries = [...state.journalEntries, entry];
          // No limit on journal entries - store them all
          return {
            journalEntries: newEntries,
            saveState: { ...state.saveState, hasUnsavedChanges: true }
          };
        });

        // Auto-save to Supabase after adding entry
        get().saveToSupabase();
      },

      updateJournalEntry: (id: string, updates: Partial<JournalEntry>) => {
        set((state) => ({
          journalEntries: state.journalEntries.map((entry) =>
            entry.id === id
              ? { ...entry, ...updates, isEdited: true, editedAt: new Date() }
              : entry,
          ),
          saveState: { ...state.saveState, hasUnsavedChanges: true }
        }));

        // Auto-save to Supabase after update
        get().saveToSupabase();
      },

      deleteJournalEntry: (id: string) => {
        set((state) => ({
          journalEntries: state.journalEntries.filter((entry) => entry.id !== id),
          saveState: { ...state.saveState, hasUnsavedChanges: true }
        }));

        // Auto-save to Supabase after deletion
        get().saveToSupabase();
      },

      completeScene: (scene: CompletedScene) => {
        set((state) => ({
          sceneHistory: [...state.sceneHistory, scene],
          saveState: { ...state.saveState, hasUnsavedChanges: true }
        }));
      },

      advanceScene: () => {
        set((state) => ({
          currentSceneIndex: state.currentSceneIndex + 1,
          saveState: { ...state.saveState, hasUnsavedChanges: true }
        }));
      },

      updateMilestone: (trustLevel: number) => {
        console.log(`ðŸ”„ [STORE] updateMilestone called for trustLevel ${trustLevel}`);
        set((state) => {
          console.log(`ðŸ”„ [STORE] Current pendingMilestoneJournals:`, state.pendingMilestoneJournals);
          
          // Check if any milestones will actually be achieved
          const milestonesToAchieve = state.milestones.filter(
            (milestone) => trustLevel >= milestone.level && !milestone.achieved
          );
          
          // If no milestones to achieve, return unchanged state to maintain reference stability
          if (milestonesToAchieve.length === 0) {
            console.log(`ðŸ”„ [STORE] No milestones to achieve - maintaining reference stability`);
            return {}; // No state change = same reference
          }
          
          // Only create new Set if we're actually adding milestones
          const newPendingJournals = new Set(state.pendingMilestoneJournals);
          console.log(`ðŸ”„ [STORE] Created new Set instance:`, newPendingJournals);
          console.log(`ðŸ”„ [STORE] Set reference changed:`, newPendingJournals !== state.pendingMilestoneJournals);
          
          const updatedMilestones = state.milestones.map((milestone) => {
            if (trustLevel >= milestone.level && !milestone.achieved) {
              // Mark milestone as achieved and add to pending journals immutably
              newPendingJournals.add(milestone.level);
              return {
                ...milestone,
                achieved: true,
                achievedAt: Date.now(),
              };
            }
            return milestone;
          });

          // Deduplicate milestones to prevent runaway state growth from old bugs
          const uniqueMilestones = updatedMilestones.filter(
            (milestone, index, self) => index === self.findIndex((m) => m.id === milestone.id),
          );

          return {
            milestones: uniqueMilestones,
            pendingMilestoneJournals: newPendingJournals,
            saveState: { ...state.saveState, hasUnsavedChanges: true }
          };
        });
      },

      markMilestoneJournalShown: (level: number) => {
        console.log(`âœ… [STORE] markMilestoneJournalShown called for level ${level}`);
        set((state) => {
          console.log(`âœ… [STORE] Current pendingMilestoneJournals:`, state.pendingMilestoneJournals);
          
          // Only create new Set if the level actually exists in the pending set
          if (!state.pendingMilestoneJournals.has(level)) {
            console.log(`âœ… [STORE] Level ${level} not in pending set - maintaining reference stability`);
            return {}; // No state change = same reference
          }
          
          // Only create new Set when we're actually removing something
          const newPendingJournals = new Set(state.pendingMilestoneJournals);
          console.log(`âœ… [STORE] Created new Set instance:`, newPendingJournals);
          console.log(`âœ… [STORE] Set reference changed:`, newPendingJournals !== state.pendingMilestoneJournals);
          newPendingJournals.delete(level);
          return { pendingMilestoneJournals: newPendingJournals };
        });
      },

      resetGame: () => {
        set((state) => ({
          guardianTrust: 50,
          playerLevel: 1,
          currentSceneIndex: 0,
          journalEntries: [],
          milestones: initialMilestones.map((m) => ({
            ...m,
            achieved: false,
            achievedAt: undefined,
          })),
          sceneHistory: [],
          pendingMilestoneJournals: new Set(),
          saveState: { ...state.saveState, hasUnsavedChanges: true }
        }));
        // Also clear from storage to prevent rehydration of bad state
        localStorage.removeItem('luminari-game-state');
      },

      _setHasHydrated: (hasHydrated: boolean) => {
        set({ _hasHydrated: hasHydrated });
      },

      // Save state utilities
      checkUnsavedChanges: () => {
        const state = get();
        return state.saveState.hasUnsavedChanges ||
               state.saveState.status === 'error' ||
               state.saveState.lastSaveTimestamp === undefined;
      },

      clearSaveError: () => {
        set((state) => ({
          saveState: {
            ...state.saveState,
            status: 'idle',
            lastError: undefined,
            retryCount: 0
          }
        }));
      },

      saveToSupabase: async () => {
        const state = get();
        
        // Don't save if already saving
        if (state.saveState.status === 'saving') {
          logger.debug('Save already in progress, skipping');
          return;
        }

        const attemptSave = async (attempt: number = 1): Promise<void> => {
          try {
            // Update save state to saving
            set((state) => ({
              saveState: {
                ...state.saveState,
                status: 'saving',
                retryCount: attempt - 1
              }
            }));

            logger.debug(`Save attempt ${attempt}/${RETRY_CONFIG.maxAttempts}`);

            const { supabase } = await import('@/lib/supabase');
            const {
              data: { user },
            } = await supabase.auth.getUser();

            if (!user) {
              throw {
                type: SaveErrorType.AUTHENTICATION_ERROR,
                message: 'No user authenticated - cannot save game state',
                originalError: null
              };
            }

            const currentState = get();
            const startTime = Date.now();

            // Prepare game state data
            const gameState = {
              user_id: user.id,
              guardian_trust: currentState.guardianTrust,
              player_level: currentState.playerLevel,
              current_scene_index: currentState.currentSceneIndex,
              milestones: currentState.milestones,
              scene_history: currentState.sceneHistory,
              updated_at: new Date().toISOString(),
            };

            logger.debug('Saving game state', {
              userId: user.id,
              guardianTrust: gameState.guardian_trust,
              journalCount: currentState.journalEntries.length
            });

            // Save game state with timeout
            const { error: stateError } = await Promise.race([
              supabase.from('game_states').upsert(gameState, { onConflict: 'user_id' }),
              new Promise((_, reject) =>
                setTimeout(() => reject(new Error('Save timeout')), 30000)
              )
            ]) as any;

            if (stateError) {
              throw {
                type: classifyError(stateError),
                message: `Failed to save game state: ${stateError.message}`,
                originalError: stateError
              };
            }

            // Save journal entries if any exist
            if (currentState.journalEntries.length > 0) {
              const journalEntries = currentState.journalEntries.map((entry) => ({
                id: entry.id,
                user_id: user.id,
                type: entry.type,
                trust_level: entry.trustLevel,
                content: entry.content,
                title: entry.title,
                scene_id: entry.sceneId || null,
                tags: entry.tags || [],
                is_edited: entry.isEdited || false,
                created_at: entry.timestamp.toISOString(),
                edited_at: entry.editedAt?.toISOString() || null,
              }));

              const { error: journalError } = await Promise.race([
                supabase.from('journal_entries').upsert(journalEntries, { onConflict: 'id' }),
                new Promise((_, reject) =>
                  setTimeout(() => reject(new Error('Journal save timeout')), 30000)
                )
              ]) as any;

              if (journalError) {
                throw {
                  type: classifyError(journalError),
                  message: `Failed to save journal entries: ${journalError.message}`,
                  originalError: journalError
                };
              }
            }

            const saveTime = Date.now() - startTime;
            logger.info('Game state saved successfully', {
              saveTime: `${saveTime}ms`,
              attempt,
              journalCount: currentState.journalEntries.length
            });

            // Update save state to success
            set((state) => ({
              saveState: {
                ...state.saveState,
                status: 'success',
                lastSaveTimestamp: Date.now(),
                lastError: undefined,
                retryCount: 0,
                hasUnsavedChanges: false
              }
            }));

          } catch (error: any) {
            const saveError: SaveError = {
              type: error.type || SaveErrorType.UNKNOWN_ERROR,
              message: error.message || 'Unknown save error',
              originalError: error.originalError || error,
              timestamp: Date.now()
            };

            const { supabase } = await import('@/lib/supabase');
            const {
              data: { user },
            } = await supabase.auth.getUser();
            
            logger.error('Save attempt failed', saveError, {
              attempt,
              userId: user?.id || 'unknown'
            });

            // Determine if we should retry
            const shouldRetry = attempt < RETRY_CONFIG.maxAttempts &&
                              isRetryableError(saveError.type);

            if (shouldRetry) {
              const delay = Math.min(
                RETRY_CONFIG.baseDelay * Math.pow(RETRY_CONFIG.backoffMultiplier, attempt - 1),
                RETRY_CONFIG.maxDelay
              );
              
              logger.info(`Retrying save in ${delay}ms`, { attempt: attempt + 1 });
              
              // Wait before retry
              await new Promise(resolve => setTimeout(resolve, delay));
              
              // Recursive retry
              return attemptSave(attempt + 1);
            } else {
              // Max attempts reached or non-retryable error
              logger.error('Save failed permanently', saveError, {
                maxAttemptsReached: attempt >= RETRY_CONFIG.maxAttempts,
                isRetryable: isRetryableError(saveError.type)
              });

              // Update save state to error
              set((state) => ({
                saveState: {
                  ...state.saveState,
                  status: 'error',
                  lastError: saveError.message,
                  retryCount: attempt,
                  hasUnsavedChanges: true
                }
              }));

              // Don't throw - we want the game to continue even if save fails
            }
          }
        };

        await attemptSave();
      },

      loadFromSupabase: async () => {
        try {
          const { supabase } = await import('@/lib/supabase');
          const {
            data: { user },
          } = await supabase.auth.getUser();

          if (!user) {
            console.warn('No user authenticated - skipping load');
            return;
          }

          // Load game state
          const { data: gameState, error: stateError } = await supabase
            .from('game_states')
            .select('*')
            .eq('user_id', user.id)
            .single();

          if (stateError && stateError.code !== 'PGRST116') {
            // PGRST116 = no rows
            console.error('Error loading game state:', stateError);
            throw stateError;
          }

          // Load journal entries
          const { data: journalEntries, error: journalError } = await supabase
            .from('journal_entries')
            .select('*')
            .eq('user_id', user.id)
            .order('created_at', { ascending: false });

          if (journalError) {
            console.error('Error loading journal entries:', journalError);
            throw journalError;
          }

          if (gameState || journalEntries) {
            set({
              ...(gameState && {
                guardianTrust: gameState.guardian_trust,
                playerLevel: gameState.player_level,
                currentSceneIndex: gameState.current_scene_index,
                milestones: gameState.milestones || initialMilestones,
                sceneHistory: gameState.scene_history || [],
              }),
              journalEntries:
                journalEntries?.map((entry) => ({
                  id: entry.id,
                  type: entry.type as 'milestone' | 'learning',
                  trustLevel: entry.trust_level,
                  content: entry.content,
                  title: entry.title,
                  timestamp: new Date(entry.created_at),
                  sceneId: entry.scene_id || undefined,
                  tags: entry.tags || undefined,
                  isEdited: entry.is_edited || false,
                  editedAt: entry.edited_at ? new Date(entry.edited_at) : undefined,
                })) || [],
            });

            console.log('Game state loaded from Supabase successfully');
          }
        } catch (error) {
          console.error('Failed to load from Supabase:', error);
          // Don't throw - we want the game to continue even if load fails
        }
      },

      // Health check methods
      performHealthCheck: async () => {
        try {
          logger.debug('Performing database health check');
          
          const result = await performEnhancedHealthCheck();
          const newHealthStatus = getCurrentHealthStatus(result);
          
          set((_state) => ({
            // TEMPORARILY COMMENTED OUT FOR BUILD: state parameter renamed to _state to fix TS6133 build error
            healthStatus: newHealthStatus
          }));
          
          if (result.success) {
            logger.debug('Health check successful', {
              responseTime: result.responseTime,
              environment: newHealthStatus.environment
            });
          } else {
            logger.warn('Health check failed', {
              error: result.error,
              responseTime: result.responseTime
            });
          }
        } catch (error: any) {
          logger.error('Health check threw exception', error);
          
          set((_state) => ({
            // TEMPORARILY COMMENTED OUT FOR BUILD: state parameter renamed to _state to fix TS6133 build error
            healthStatus: {
              isConnected: false,
              responseTime: 0,
              lastChecked: Date.now(),
              error: error.message || 'Health check failed',
              environment: detectEnvironment()
            }
          }));
        }
      },

      startHealthMonitoring: () => {
        const state = get();
        
        // Don't start monitoring if already running
        if (state._isHealthMonitoringActive || state._healthCheckInterval) {
          logger.debug('Health monitoring already running');
          return;
        }
        
        logger.info('Starting database health monitoring');
        
        // Mark as active immediately to prevent race conditions
        set({ _isHealthMonitoringActive: true });
        
        // Perform initial health check
        get().performHealthCheck();
        
        // Set up periodic health checks (every 45 seconds)
        const interval = setInterval(() => {
          const currentState = get();
          
          // Only perform health check if the app is active and user is present
          if (document.hidden || !document.hasFocus()) {
            logger.debug('Skipping health check - app not active');
            return;
          }
          
          currentState.performHealthCheck();
        }, 45000); // 45 seconds
        
        // Store interval reference
        set({ _healthCheckInterval: interval });
      },

      stopHealthMonitoring: () => {
        const state = get();
        
        if (state._healthCheckInterval) {
          logger.info('Stopping database health monitoring');
          clearInterval(state._healthCheckInterval);
          set({ 
            _healthCheckInterval: undefined,
            _isHealthMonitoringActive: false 
          });
        }
      },
    }),
    {
      name: 'luminari-game-state',
      partialize: (state) => ({
        guardianTrust: state.guardianTrust,
        playerLevel: state.playerLevel,
        currentSceneIndex: state.currentSceneIndex,
        journalEntries: state.journalEntries.map((entry) => ({
          ...entry,
          timestamp: entry.timestamp.toISOString(),
        })),
        milestones: state.milestones.map((milestone) => ({
          ...milestone,
          achievedAt: milestone.achievedAt
            ? new Date(milestone.achievedAt).toISOString()
            : undefined,
        })),
        sceneHistory: state.sceneHistory.map((scene) => ({
          ...scene,
          completedAt: new Date(scene.completedAt).toISOString(),
        })),
      }),
      // Add a merge function to handle rehydration
      merge: (persistedState: any, currentState) => {
        if (!persistedState) return currentState;

        // Convert ISO strings back to Date objects
        const hydratedJournalEntries = (persistedState.journalEntries || []).map((entry: any) => ({
          ...entry,
          timestamp: new Date(entry.timestamp),
        }));

        // Properly merge milestones, ensuring we don't duplicate and maintain initial structure
        const mergedMilestones = initialMilestones.map((initialMilestone) => {
          const persistedMilestone = (persistedState.milestones || []).find(
            (m: any) => m.id === initialMilestone.id,
          );
          return persistedMilestone
            ? {
                ...initialMilestone,
                ...persistedMilestone,
                achievedAt: persistedMilestone.achievedAt
                  ? new Date(persistedMilestone.achievedAt).getTime()
                  : undefined,
              }
            : initialMilestone;
        });

        return {
          ...currentState,
          ...persistedState,
          journalEntries: hydratedJournalEntries,
          milestones: mergedMilestones,
        };
      },
      onRehydrateStorage: () => (state) => {
        state?._setHasHydrated(true);
      },
    },
  ),
);

// Hydration-safe hook that prevents mismatches
export const useGameStore = () => {
  const store = useGameStoreBase();
  const [hasMounted, setHasMounted] = useState(false);

  useEffect(() => {
    setHasMounted(true);
  }, []);

  // Return initial values during SSR/hydration to prevent mismatches
  if (!hasMounted || !store._hasHydrated) {
    return {
      guardianTrust: 50,
      playerLevel: 1,
      currentSceneIndex: 0,
      journalEntries: [],
      milestones: initialMilestones,
      sceneHistory: [],
      pendingMilestoneJournals: new Set(),
      saveState: {
        status: 'idle',
        retryCount: 0,
        hasUnsavedChanges: false
      } as SaveState,
      healthStatus: {
        isConnected: false,
        responseTime: 0,
        lastChecked: 0,
        environment: detectEnvironment()
      } as DatabaseHealthStatus,
      setGuardianTrust: store.setGuardianTrust,
      addJournalEntry: store.addJournalEntry,
      updateJournalEntry: store.updateJournalEntry,
      deleteJournalEntry: store.deleteJournalEntry,
      completeScene: store.completeScene,
      advanceScene: store.advanceScene,
      saveToSupabase: store.saveToSupabase,
      loadFromSupabase: store.loadFromSupabase,
      resetGame: store.resetGame,
      updateMilestone: store.updateMilestone,
      markMilestoneJournalShown: store.markMilestoneJournalShown,
      checkUnsavedChanges: store.checkUnsavedChanges,
      clearSaveError: store.clearSaveError,
      performHealthCheck: store.performHealthCheck,
      startHealthMonitoring: store.startHealthMonitoring,
      stopHealthMonitoring: store.stopHealthMonitoring,
      _hasHydrated: false,
      _setHasHydrated: store._setHasHydrated,
    };
  }

  return store;
};
